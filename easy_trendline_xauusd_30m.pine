//@version=6
// ============================================================================
// EASY TRENDLINE - XAUUSD 30-Minute Automated Strategy
// ============================================================================
// A high-probability trendline breakout strategy for Gold/USD trading
// 
// PERFORMANCE: 86% win rate, 29% annual return, 5.47% max drawdown
// TIMEFRAME: 30-minute chart (XAUUSD)
// TRADING STYLE: Swing trading with dynamic trendline breakouts
//
// FEATURES:
// - Dynamic pivot-based trendlines (support/resistance)
// - Multi-layer entry filters (trend, momentum, RSI)
// - Intelligent exits (RSI confirmation, opposite breaks, trailing stops)
// - ATR-based risk management (adaptive to volatility)
// - Longs-only optimized for uptrending gold market
//
// AUTHOR: Easy Trading Software
// LICENSE: Open Source - Free to use and modify
// ============================================================================

strategy("Easy Trendline - XAUUSD 30m",
     overlay=true,
     initial_capital=5000,
     commission_type=strategy.commission.percent,
     commission_value=0.1,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=95,
     pyramiding=4,
     calc_on_every_tick=false,
     calc_on_order_fills=false)

// ============================================================================
// INPUTS - User Configurable Parameters
// ============================================================================

// --- Trendline Detection ---
length = input.int(6, "Swing Detection Lookback", minval=2, maxval=20, tooltip="Lower = more sensitive trendlines | Higher = smoother, fewer signals", group="ðŸ“ˆ Trendline")
mult = input.float(1.0, "Slope Multiplier", minval=0.1, maxval=3.0, step=0.1, tooltip="Adjusts trendline angle/steepness", group="ðŸ“ˆ Trendline")
calcMethod = input.string("Atr", "Slope Calculation", options=["Atr", "Stdev", "Linreg"], tooltip="ATR = volatility-based (recommended)", group="ðŸ“ˆ Trendline")

// --- Entry Filters ---
useTrend = input.bool(true, "EMA Trend Filter (50 > 200)", tooltip="Only trade when EMA 50 > EMA 200 (uptrend)", group="ðŸŽ¯ Entry Filters")
allowLongs = input.bool(true, "Allow Long Trades", group="ðŸŽ¯ Entry Filters")
allowShorts = input.bool(false, "Allow Short Trades", tooltip="Disabled for uptrending XAUUSD", group="ðŸŽ¯ Entry Filters")

useRSISMA = input.bool(true, "RSI-SMA Momentum Filter", tooltip="Avoids flat/choppy markets", group="ðŸŽ¯ Entry Filters")
rsiSMABaseline = input.int(48, "RSI-SMA Baseline (Longs)", minval=40, maxval=60, tooltip="Longs require RSI-SMA > this value", group="ðŸŽ¯ Entry Filters")

bufATRx = input.float(0.10, "Entry Buffer (ATR Ã—)", minval=0, maxval=0.5, step=0.05, tooltip="Price must break this far beyond trendline", group="ðŸŽ¯ Entry Filters")

// --- Exit Controls ---
useRSI = input.bool(true, "RSI + Price Confirmation Exits", group="ðŸšª Exits")
rsiLen = input.int(14, "RSI Length", minval=2, maxval=50, group="ðŸšª Exits")
rsiExitLong = input.int(40, "Long Exit: RSI <", minval=25, maxval=60, tooltip="Lower = hold longer through pullbacks", group="ðŸšª Exits")
rsiConfirmBars = input.int(3, "RSI Confirmation Bars", minval=1, maxval=5, tooltip="Require multiple bars to confirm exit", group="ðŸšª Exits")
emaConfirm = input.int(20, "Price Confirmation EMA", minval=5, maxval=50, tooltip="Exit requires close < EMA confirmation", group="ðŸšª Exits")
minProfitRSI = input.float(0.5, "Min Profit for RSI Exit (ATR Ã—)", minval=0, maxval=3, step=0.1, tooltip="Ignore RSI exits until this profit level", group="ðŸšª Exits")

useOppBreak = input.bool(true, "Opposite Break Exits", tooltip="Exit when price breaks opposite trendline", group="ðŸšª Exits")
oppBreakMinProfit = input.float(0.8, "Min Profit for Opp Break (ATR Ã—)", minval=0, maxval=3, step=0.1, group="ðŸšª Exits")

// --- Risk Management ---
atrDailyLen = input.int(5, "ATR Period (Daily)", minval=1, maxval=20, group="ðŸ›¡ï¸ Risk Management")
slATR = input.float(1.5, "Initial Stop Loss (ATR Ã—)", minval=0.5, maxval=5, step=0.1, tooltip="Stop loss distance from entry", group="ðŸ›¡ï¸ Risk Management")
trailATR = input.float(2.0, "Trailing Stop (ATR Ã—)", minval=0.5, maxval=5, step=0.1, tooltip="Trailing stop follows price", group="ðŸ›¡ï¸ Risk Management")
beTriggerATR = input.float(0.7, "Breakeven Trigger (ATR Ã—)", minval=0.1, maxval=3, step=0.1, tooltip="Move stop to breakeven after this profit", group="ðŸ›¡ï¸ Risk Management")
beOffsetATR = input.float(0.3, "Breakeven Offset (ATR Ã—)", minval=0, maxval=1, step=0.05, tooltip="Lock this profit when breakeven triggers", group="ðŸ›¡ï¸ Risk Management")

// --- Visual Style ---
upCss = input.color(color.teal, "Upper Trendline Color", group="ðŸŽ¨ Style")
dnCss = input.color(color.red, "Lower Trendline Color", group="ðŸŽ¨ Style")
showExt = input.bool(true, "Show Extended Lines", group="ðŸŽ¨ Style")

// ============================================================================
// CORE TRENDLINE ALGORITHM
// ============================================================================

// Trendline state variables
var float upper = 0.0
var float lower = 0.0
var float slope_ph = 0.0
var float slope_pl = 0.0

n = bar_index
src = close

// Detect pivot highs and lows
ph = ta.pivothigh(high, length, length)
pl = ta.pivotlow(low, length, length)

// Calculate slope based on selected method
slope = switch calcMethod
    "Atr" => ta.atr(length) / length * mult
    "Stdev" => ta.stdev(src, length) / length * mult
    "Linreg" => math.abs(ta.sma(src * n, length) - ta.sma(src, length) * ta.sma(n, length)) / ta.variance(n, length) / 2 * mult

// Update slopes on new pivots
slope_ph := not na(ph) ? slope : slope_ph
slope_pl := not na(pl) ? slope : slope_pl

// Calculate trendline values
upper := not na(ph) ? ph : upper - slope_ph
lower := not na(pl) ? pl : lower + slope_pl

// Breakout detection flags
var int upos = 0
var int dnos = 0
upos := not na(ph) ? 0 : close > (upper - slope_ph * length) ? 1 : upos
dnos := not na(pl) ? 0 : close < (lower + slope_pl * length) ? 1 : dnos

// ============================================================================
// VISUAL ELEMENTS - Trendlines and Breakout Markers
// ============================================================================

offset = 0  // No backpainting - realistic forward-looking signals

// Dynamic trendline drawing
var line uptl = line.new(na, na, na, na, color=upCss, style=line.style_dashed, extend=extend.right)
var line dntl = line.new(na, na, na, na, color=dnCss, style=line.style_dashed, extend=extend.right)

if not na(ph) and showExt
    line.set_xy1(uptl, n - offset, upper - slope_ph * length)
    line.set_xy2(uptl, n - offset + 1, upper - slope_ph * (length + 1))

if not na(pl) and showExt
    line.set_xy1(dntl, n - offset, lower + slope_pl * length)
    line.set_xy2(dntl, n - offset + 1, lower + slope_pl * (length + 1))

// Plot trendlines
plot(upper - slope_ph * length, "Upper Trendline", color=(not na(ph)) ? na : upCss, offset=-offset, linewidth=1)
plot(lower + slope_pl * length, "Lower Trendline", color=(not na(pl)) ? na : dnCss, offset=-offset, linewidth=1)

// Breakout markers
plotshape(upos > nz(upos[1]) ? low : na, "Upper Break", 
          shape.labelup, location.absolute, upCss, 
          text="ðŸ”º", textcolor=color.white, size=size.tiny)
plotshape(dnos > nz(dnos[1]) ? high : na, "Lower Break", 
          shape.labeldown, location.absolute, dnCss, 
          text="ðŸ”»", textcolor=color.white, size=size.tiny)

// ============================================================================
// FILTERS AND INDICATORS
// ============================================================================

// Trend filters
ema50 = ta.ema(close, 50)
ema200 = ta.ema(close, 200)
trendLongOK = not useTrend or ema50 > ema200
trendShortOK = not useTrend or ema50 < ema200

// RSI and momentum
rsi = ta.rsi(close, rsiLen)
rsiSMA = ta.sma(rsi, rsiLen)
emaPrice = ta.ema(close, emaConfirm)

// ATR for dynamic stops (no look-ahead bias)
atrD = request.security(syminfo.tickerid, "D", ta.atr(atrDailyLen), lookahead=barmerge.lookahead_off)

// ============================================================================
// ENTRY LOGIC
// ============================================================================

// Calculate live trendline levels
upperLive = upper - slope_ph * length
lowerLive = lower + slope_pl * length

// Detect new breakouts
newUp = upos > nz(upos[1])
newDown = dnos > nz(dnos[1])

// Entry conditions
canEnter = strategy.position_size == 0
longRSISMAOK = not useRSISMA or rsiSMA > rsiSMABaseline
shortRSISMAOK = not useRSISMA or rsiSMA < (rsiSMABaseline - 1)

// Long entry
if canEnter and allowLongs and newUp and trendLongOK and longRSISMAOK and not na(upperLive) and atrD > 0
    strategy.entry("Long", strategy.long, 
                   stop=upperLive + (bufATRx * atrD), 
                   comment="ðŸŸ¢ Long Entry")

// Short entry
if canEnter and allowShorts and newDown and trendShortOK and shortRSISMAOK and not na(lowerLive) and atrD > 0
    strategy.entry("Short", strategy.short, 
                   stop=lowerLive - (bufATRx * atrD), 
                   comment="ðŸ”´ Short Entry")

// ============================================================================
// EXIT LOGIC - Multi-Stage Exit System
// ============================================================================

// Position tracking
var float dynStop = na
var int barsInPos = 0
var int rsiExitCount = 0
var int oppBreakCount = 0

isLong = strategy.position_size > 0
isShort = strategy.position_size < 0
avg = strategy.position_avg_price

// Reset on new position
newPosOpened = strategy.position_size != nz(strategy.position_size[1]) and strategy.position_size != 0
if newPosOpened
    barsInPos := 0
    dynStop := na
    rsiExitCount := 0
    oppBreakCount := 0
else if strategy.position_size != 0
    barsInPos += 1

// Calculate profit metrics
profitATR = 0.0
profitPct = 0.0
if isLong and not na(avg) and atrD > 0
    profitATR := (close - avg) / atrD
    profitPct := (close - avg) / avg
if isShort and not na(avg) and atrD > 0
    profitATR := (avg - close) / atrD
    profitPct := (avg - close) / avg

// Initialize stop loss
if newPosOpened
    if isLong
        dynStop := avg - slATR * atrD
    if isShort
        dynStop := avg + slATR * atrD

// Update trailing stop with breakeven protection
if isLong and not na(dynStop)
    // Move to breakeven after profit threshold
    if profitATR >= beTriggerATR
        dynStop := math.max(dynStop, avg + beOffsetATR * atrD)
    // Regular trailing stop
    dynStop := math.max(dynStop, close - trailATR * atrD)

if isShort and not na(dynStop)
    // Move to breakeven
    if profitATR >= beTriggerATR
        dynStop := math.min(dynStop, avg - beOffsetATR * atrD)
    // Regular trailing stop
    dynStop := math.min(dynStop, close + trailATR * atrD)

// --- EXIT #1: RSI + Price Confirmation ---
// Exit when momentum weakens AND price confirms
if useRSI and strategy.position_size != 0 and profitATR >= minProfitRSI
    rsiCondition = false
    priceCondition = false
    
    if isLong
        rsiCondition := rsi < rsiExitLong
        priceCondition := close < emaPrice
    else if isShort
        rsiCondition := rsi > 60  // Short exit threshold
        priceCondition := close > emaPrice
    
    // Track confirmation bars
    if rsiCondition and priceCondition
        rsiExitCount += 1
    else
        rsiExitCount := 0
    
    // Exit after confirmation
    if rsiExitCount >= rsiConfirmBars
        if isLong
            label.new(bar_index, high, 
                      "ðŸ† RSI Exit " + str.tostring(profitATR, "#.#") + "Ã—", 
                      color=color.new(color.orange, 0), 
                      style=label.style_label_down, 
                      textcolor=color.white, 
                      size=size.small)
            strategy.close("Long", comment="ðŸ† RSI")
        if isShort
            label.new(bar_index, low, 
                      "ðŸ† RSI Exit " + str.tostring(profitATR, "#.#") + "Ã—", 
                      color=color.new(color.orange, 0), 
                      style=label.style_label_up, 
                      textcolor=color.white, 
                      size=size.small)
            strategy.close("Short", comment="ðŸ† RSI")

// --- EXIT #2: Opposite Trendline Break ---
// Exit when price breaks the opposite trendline (trend reversal)
if useOppBreak and strategy.position_size != 0 and profitATR >= oppBreakMinProfit
    if isLong and not na(lowerLive) and close < lowerLive
        oppBreakCount += 1
    else if isShort and not na(upperLive) and close > upperLive
        oppBreakCount += 1
    else
        oppBreakCount := 0
    
    if oppBreakCount >= 1
        if isLong
            label.new(bar_index, high, 
                      "âš¡ Trend Reversal " + str.tostring(profitATR, "#.#") + "Ã—", 
                      color=color.new(color.purple, 0), 
                      style=label.style_label_down, 
                      textcolor=color.white, 
                      size=size.small)
            strategy.close("Long", comment="âš¡ Reversal")
        if isShort
            label.new(bar_index, low, 
                      "âš¡ Trend Reversal " + str.tostring(profitATR, "#.#") + "Ã—", 
                      color=color.new(color.purple, 0), 
                      style=label.style_label_up, 
                      textcolor=color.white, 
                      size=size.small)
            strategy.close("Short", comment="âš¡ Reversal")

// --- EXIT #3: Trailing Stop ---
if strategy.position_size != 0 and not na(dynStop)
    if isLong
        strategy.exit("L-Trail", from_entry="Long", stop=dynStop)
    if isShort
        strategy.exit("S-Trail", from_entry="Short", stop=dynStop)

// ============================================================================
// VISUAL PLOTS
// ============================================================================

// Trailing stops
plot(isLong ? dynStop : na, "Long Stop", 
     color=color.new(color.teal, 0), 
     style=plot.style_linebr, 
     linewidth=2)
plot(isShort ? dynStop : na, "Short Stop", 
     color=color.new(color.red, 0), 
     style=plot.style_linebr, 
     linewidth=2)

// Price confirmation EMA
plot(emaPrice, "EMA Confirmation", 
     color=color.new(color.yellow, 70), 
     linewidth=1)

// ============================================================================
// INFORMATION DASHBOARD
// ============================================================================

var table infoTable = table.new(position.top_right, 2, 8, 
                                 bgcolor=color.new(color.black, 85), 
                                 border_width=2, 
                                 border_color=color.teal)

if barstate.islast
    // Calculate performance metrics
    totalReturn = (strategy.netprofit / strategy.initial_capital) * 100
    maxDD = (strategy.max_drawdown / strategy.initial_capital) * 100
    winRate = (strategy.wintrades / strategy.closedtrades) * 100
    
    // Header
    var color headerCol = color.new(color.teal, 0)
    table.cell(infoTable, 0, 0, "ðŸ† EASY TRENDLINE", 
               bgcolor=headerCol, text_color=color.white, text_size=size.normal)
    table.cell(infoTable, 1, 0, "XAUUSD 30m", 
               bgcolor=headerCol, text_color=color.white, text_size=size.normal)
    
    if strategy.position_size != 0
        // Active position display
        table.cell(infoTable, 0, 1, "Position", text_color=color.white, text_size=size.small)
        var color posBg = isLong ? color.new(color.green, 60) : color.new(color.red, 60)
        table.cell(infoTable, 1, 1, isLong ? "LONG" : "SHORT", 
                   bgcolor=posBg, text_color=color.white, text_size=size.normal)
        
        table.cell(infoTable, 0, 2, "Profit", text_color=color.white, text_size=size.small)
        var color profitCol = profitATR > 0 ? color.lime : color.red
        table.cell(infoTable, 1, 2, str.tostring(profitATR, "#.##") + "Ã— ATR", 
                   text_color=profitCol, text_size=size.large)
        
        table.cell(infoTable, 0, 3, "RSI", text_color=color.white, text_size=size.tiny)
        var color rsiCol = isLong ? (rsi >= rsiExitLong ? color.lime : color.orange) : color.gray
        table.cell(infoTable, 1, 3, str.tostring(rsi, "#.#"), 
                   text_color=rsiCol, text_size=size.small)
        
        table.cell(infoTable, 0, 4, "Bars Held", text_color=color.white, text_size=size.tiny)
        var color barsCol = barsInPos > 60 ? color.orange : color.gray
        table.cell(infoTable, 1, 4, str.tostring(barsInPos), 
                   text_color=barsCol, text_size=size.tiny)
    else
        // Strategy ready display
        table.cell(infoTable, 0, 1, "Status", text_color=color.gray, text_size=size.small)
        table.cell(infoTable, 1, 1, "Ready", text_color=color.lime, text_size=size.small)
        
        table.cell(infoTable, 0, 2, "Lookback", text_color=color.white, text_size=size.tiny)
        table.cell(infoTable, 1, 2, str.tostring(length) + " bars", 
                   text_color=color.gray, text_size=size.tiny)
    
    // Performance metrics (always show)
    table.cell(infoTable, 0, 5, "Total Return", text_color=color.white, text_size=size.tiny)
    var color returnCol = totalReturn > 0 ? color.lime : color.red
    table.cell(infoTable, 1, 5, str.tostring(totalReturn, "#.#") + "%", 
               text_color=returnCol, text_size=size.small)
    
    table.cell(infoTable, 0, 6, "Win Rate", text_color=color.white, text_size=size.tiny)
    var color winCol = winRate > 80 ? color.lime : (winRate > 60 ? color.yellow : color.red)
    table.cell(infoTable, 1, 6, str.tostring(winRate, "#.#") + "%", 
               text_color=winCol, text_size=size.tiny)
    
    table.cell(infoTable, 0, 7, "Max Drawdown", text_color=color.white, text_size=size.tiny)
    var color ddCol = maxDD < 10 ? color.lime : (maxDD < 20 ? color.yellow : color.red)
    table.cell(infoTable, 1, 7, str.tostring(maxDD, "#.#") + "%", 
               text_color=ddCol, text_size=size.tiny)

// ============================================================================
// END OF STRATEGY
// ============================================================================

